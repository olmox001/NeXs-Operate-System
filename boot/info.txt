# x86_64 Bootloader (Stage 1 & Stage 2)

A custom two-stage bootstrap system for **x86_64 Long Mode**, featuring a complete transition from Real Mode to 64-bit mode, E820 memory detection, and Flat Binary kernel loading.

## Architecture

### Stage 1 - Master Boot Record (MBR)
**Load Address**: `0x7C00`
**Size**: 512 bytes (1 sector)
**Mode**: Real Mode (16-bit)

#### Responsibilities
1. **Environment Setup**: Initializes stack and segments.
2. **LBA Detection**: Checks for INT 13h Extensions support.
3. **Stage 2 Loading**: Loads 32 sectors (16KB) to `0x7E00`.
4. **Validation**: Checks for the `0xAA55` signature.
5. **Handoff**: Far jump to Stage 2.

### Stage 2 - x86_64 Long Mode Loader
**Load Address**: `0x7E00`
**Size**: 16KB (32 sectors)
**Mode**: Real Mode → Protected Mode → Long Mode (16→32→64 bit)

#### Transition Pipeline
1.  **Real Mode**: Enable A20 Gate.
2.  **E820 Memory Detection**: Query BIOS for memory map (up to 32 entries).
3.  **Load Kernel**: Reads Flat Binary from disk (Sector 64+) to `0x10000`.
4.  **Paging Setup**: Identity Map the first 16MB using Huge Pages (2MB).
5.  **GDT Setup**: Load 64-bit GDT.
6.  **Enter Long Mode**: Enable PAE → Load CR3 → Enable LME → Enable Paging.
7.  **Relocation**: Move kernel to `0x100000` (1MB).
8.  **Execution**: Jump to Kernel Entry Point with `boot_info` in RDI.

## boot_info Structure

Passed to kernel in RDI register:

```c
struct boot_info {
    uint64_t magic;           // 0xDEADBEEF
    uint16_t e820_count;      // Number of E820 entries
    uint16_t reserved;
    uint32_t total_memory_mb; // Total usable RAM in MB
    uint64_t secure_base;     // Secure key storage (set by kernel)
    uint64_t heap_base;       // Heap start
    uint64_t heap_size;       // Heap size
};

// E820 entries follow boot_info (24 bytes each)
struct e820_entry {
    uint64_t base;
    uint64_t length;
    uint32_t type;    // 1=Usable, 2=Reserved, 3=ACPI, 4=NVS
    uint32_t attrs;
};
```

## Technical Details

### Memory Map (Physical)
*   `0x000000 - 0x000FFF`: Real Mode IDT / BIOS Data
*   `0x001000 - 0x003FFF`: Page Tables (PML4, PDPT, PDT)
*   `0x007C00 - 0x007DFF`: Stage 1 (MBR)
*   `0x007E00 - 0x00BE00`: Stage 2 (Loader)
*   `0x008500 - 0x008570`: boot_info structure
*   `0x008570 - 0x008870`: E820 memory map (32 entries × 24 bytes)
*   `0x010000 - 0x02FFFF`: Kernel Load Buffer (Temp)
*   `0x0B8000 - 0x0BFFFF`: Video Memory (VGA)
*   `0x100000 - 0x1FFFFF`: **Kernel Code & Data**
*   `0x200000+`: **Dynamic Heap** (from E820)

### Kernel Interface
When control is transferred to the kernel:

*   **RDI**: Pointer to `boot_info` structure.
*   **RSP**: `0x200000` (Stack Top).
*   **RIP**: `0x100000` (Entry Point).
*   **Mode**: 64-bit Long Mode, Interrupts Disabled.
*   **CS**: `0x08` (64-bit Code).
*   **DS/ES/SS**: `0x10` (Data).

### E820 Memory Types
| Type | Description |
|------|-------------|
| 1 | Usable RAM |
| 2 | Reserved |
| 3 | ACPI Reclaimable |
| 4 | ACPI NVS |
| 5 | Bad Memory |

## Build System
*   **Stage 1**: `nasm -f bin boot/stage1.asm -o boot/stage1.bin`
*   **Stage 2**: `nasm -f bin boot/stage2.asm -o boot/stage2.bin`
*   **Kernel**:  `./build_kernel.sh [--release]`
*   **Test**: `./build_and_test.sh` (creates disk image and runs QEMU)

See `README.md` for full build instructions.